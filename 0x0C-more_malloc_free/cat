5,7c5,9
< void populateResult(char *dest, char *n1, int n1_len, char *n2, int n2_len);
< int getLengthOfNum(char *str);
< void print_result(char *src, int length);
---
> int find_len(char *str);
> char *create_xarray(int size);
> char *iterate_zeroes(char *str);
> void get_prod(char *prod, char *mult, int digit, int zeroes);
> void add_nums(char *final_prod, char *next_prod, int next_len);
10c12,13
<  * main - entry point, multiplies two numbers
---
>  * find_len - Finds the length of a string.
>  * @str: The string to be measured.
12,16c15
<  * @argc: integer, length of @argv
<  *
<  * @argv: one-dimensional array of strings, arguments of this program
<  *
<  * Return: 0, success
---
>  * Return: The length of the string.
18,19c17
< 
< int main(int argc, char *argv[])
---
> int find_len(char *str)
21,22c19
< 	int num1_length, num2_length;
< 	char *result;
---
> 	int len = 0;
24,28c21,22
< 	if (argc != 3)
< 	{
< 		printf("Error\n");
< 		exit(98);
< 	}
---
> 	while (*str++)
> 		len++;
30c24,25
< 	num1_length = getLengthOfNum(argv[1]);
---
> 	return (len);
> }
32,36c27,39
< 	if (!num1_length)
< 	{
< 		printf("Error\n");
< 		exit(98);
< 	}
---
> /**
>  * create_xarray - Creates an array of chars and initializes it with
>  *                 the character 'x'. Adds a terminating null byte.
>  * @size: The size of the array to be initialized.
>  *
>  * Description: If there is insufficient space, the
>  *              function exits with a status of 98.
>  * Return: A pointer to the array.
>  */
> char *create_xarray(int size)
> {
> 	char *array;
> 	int index;
38c41
< 	num2_length = getLengthOfNum(argv[2]);
---
> 	array = malloc(sizeof(char) * size);
40,42c43
< 	if (!num2_length)
< 	{
< 		printf("Error\n");
---
> 	if (array == NULL)
44d44
< 	}
46c46,47
< 	result = malloc(num1_length + num2_length);
---
> 	for (index = 0; index < (size - 1); index++)
> 		array[index] = 'x';
48,49c49
< 	if (!result)
< 		return (1);
---
> 	array[index] = '\0';
51c51,52
< 	populateResult(result, argv[1], num1_length, argv[2], num2_length);
---
> 	return (array);
> }
53,55c54,64
< 	print_result(result, num1_length + num2_length);
< 	printf("\n");
< 	free(result);
---
> /**
>  * iterate_zeroes - Iterates through a string of numbers containing
>  *                  leading zeroes until it hits a non-zero number.
>  * @str: The string of numbers to be iterate through.
>  *
>  * Return: A pointer to the next non-zero element.
>  */
> char *iterate_zeroes(char *str)
> {
> 	while (*str && *str == '0')
> 		str++;
57c66
< 	return (0);
---
> 	return (str);
61,63c70,71
<  * getLengthOfNum - length of numbers in a string
<  *
<  * @str: pointer to string of numbers
---
>  * get_digit - Converts a digit character to a corresponding int.
>  * @c: The character to be converted.
65,66c73,75
<  * Return: integer (SUCCESS) or
<  * NULL, if string includes char
---
>  * Description: If c is a non-digit, the function
>  *              exits with a status of 98.
>  * Return: The converted int.
68,69c77
< 
< int getLengthOfNum(char *str)
---
> int get_digit(char c)
71c79
< 	int i = 0;
---
> 	int digit = c - '0';
73c81
< 	while (str[i])
---
> 	if (digit < 0 || digit > 9)
75,79c83,84
< 		if (str[i] >= '0' && str[i] <= '9')
< 			i++;
< 		else
< 			return ('\0');
< 
---
> 		printf("Error\n");
> 		exit(98);
82c87
< 	return (i);
---
> 	return (digit);
86,89c91,95
<  * populateResult - multiplies two numbers stored as string
<  * and stores result in @dest
<  *
<  * @dest: pointer to where @num1 * @num2 should be stored
---
>  * get_prod - Multiplies a string of numbers by a single digit.
>  * @prod: The buffer to store the result.
>  * @mult: The string of numbers.
>  * @digit: The single digit.
>  * @zeroes: The necessary number of leading zeroes.
91,97c97,98
<  * @n1: positive number stored as string in an array
<  *
<  * @n2: positive number stored as string in an array
<  *
<  * @n1_len: length of @n1
<  *
<  * @n2_len: length of @n2
---
>  * Description: If mult contains a non-digit, the function
>  *              exits with a status value of 98.
99,100c100
< 
< void populateResult(char *dest, char *n1, int n1_len, char *n2, int n2_len)
---
> void get_prod(char *prod, char *mult, int digit, int zeroes)
102,104c102
< 	int i, j, k, temp_value, non_carry_value;
< 	int carry_value = 0;
< 	char *multiplicand, *multiplier;
---
> 	int mult_len, num, tens = 0;
106c104,107
< 	if (n1_len > n2_len)
---
> 	mult_len = find_len(mult) - 1;
> 	mult += mult_len;
> 
> 	while (*prod)
108,111c109,110
< 		i = n1_len - 1;
< 		j = n2_len - 1;
< 		multiplicand = n1;
< 		multiplier = n2;
---
> 		*prod = 'x';
> 		prod++;
113c112,115
< 	else
---
> 
> 	prod--;
> 
> 	while (zeroes--)
115,118c117,118
< 		i = n2_len - 1;
< 		j = n1_len - 1;
< 		multiplicand = n2;
< 		multiplier = n1;
---
> 		*prod = '0';
> 		prod--;
121c121
< 	while (i >= 0)
---
> 	for (; mult_len >= 0; mult_len--, mult--, prod--)
123,125c123
< 		k = i;
< 
< 		while (k >= 0)
---
> 		if (*mult < '0' || *mult > '9')
127,128c125,127
< 			temp_value = ((multiplicand[k] - '0') * (multiplier[j] - '0'));
< 			temp_value += carry_value;
---
> 			printf("Error\n");
> 			exit(98);
> 		}
130,131c129,133
< 			if (j + 1 <= n2_len - 1 && dest[k + j + 1] >= '0' && dest[k + j + 1] <= '9')
< 				temp_value += dest[k + j + 1] - '0';
---
> 		num = (*mult - '0') * digit;
> 		num += tens;
> 		*prod = (num % 10) + '0';
> 		tens = num / 10;
> 	}
133,142c135,137
< 			if (temp_value < 10)
< 			{
< 				non_carry_value = temp_value;
< 				carry_value = 0;
< 			}
< 			else
< 			{
< 				non_carry_value = temp_value % 10;
< 				carry_value = temp_value / 10;
< 			}
---
> 	if (tens)
> 		*prod = (tens % 10) + '0';
> }
144,146c139,147
< 			dest[k + j + 1] = non_carry_value + '0';
< 			k--;
< 		}
---
> /**
>  * add_nums - Adds the numbers stored in two strings.
>  * @final_prod: The buffer storing the running final product.
>  * @next_prod: The next product to be added.
>  * @next_len: The length of next_prod.
>  */
> void add_nums(char *final_prod, char *next_prod, int next_len)
> {
> 	int num, tens = 0;
148,149c149,150
< 		if (carry_value)
< 			dest[k + j + 1] = carry_value + '0';
---
> 	while (*(final_prod + 1))
> 		final_prod++;
151c152,153
< 		carry_value = 0;
---
> 	while (*(next_prod + 1))
> 		next_prod++;
153,156c155,163
< 		if (j > 0)
< 			j--;
< 		else
< 			i = -1;
---
> 	for (; *final_prod != 'x'; final_prod--)
> 	{
> 		num = (*final_prod - '0') + (*next_prod - '0');
> 		num += tens;
> 		*final_prod = (num % 10) + '0';
> 		tens = num / 10;
> 
> 		next_prod--;
> 		next_len--;
159,161c166,178
< 	free(dest);
< 	free(multiplicand);
< 	free(multiplier);
---
> 	for (; next_len >= 0 && *next_prod != 'x'; next_len--)
> 	{
> 		num = (*next_prod - '0');
> 		num += tens;
> 		*final_prod = (num % 10) + '0';
> 		tens = num / 10;
> 
> 		final_prod--;
> 		next_prod--;
> 	}
> 
> 	if (tens)
> 		*final_prod = (tens % 10) + '0';
165,169c182,188
<  * print_result - prints numbers stored as string in a memory location
<  *
<  * @src: pointer to memory that stores numbers as strings
<  *
<  * @length: length of @src
---
>  * main - Multiplies two positive numbers.
>  * @argv: The number of arguments passed to the program.
>  * @argc: An array of pointers to the arguments.
>  *
>  * Description: If the number of arguments is incorrect or one number
>  *              contains non-digits, the function exits with a status of 98.
>  * Return: Always 0.
171,172c190
< 
< void print_result(char *src, int length)
---
> int main(int argc, char *argv[])
174c192,199
< 	int i;
---
> 	char *final_prod, *next_prod;
> 	int size, index, digit, zeroes = 0;
> 
> 	if (argc != 3)
> 	{
> 		printf("Error\n");
> 		exit(98);
> 	}
176c201,205
< 	for (i = 0; i < length; i++)
---
> 	if (*(argv[1]) == '0')
> 		argv[1] = iterate_zeroes(argv[1]);
> 	if (*(argv[2]) == '0')
> 		argv[2] = iterate_zeroes(argv[2]);
> 	if (*(argv[1]) == '\0' || *(argv[2]) == '\0')
178,179c207,208
< 		if (src[i] >= '0' && src[i] <= '9')
< 		printf("%c", src[i]);
---
> 		printf("0\n");
> 		return (0);
180a210,231
> 
> 	size = find_len(argv[1]) + find_len(argv[2]);
> 	final_prod = create_xarray(size + 1);
> 	next_prod = create_xarray(size + 1);
> 
> 	for (index = find_len(argv[2]) - 1; index >= 0; index--)
> 	{
> 		digit = get_digit(*(argv[2] + index));
> 		get_prod(next_prod, argv[1], digit, zeroes++);
> 		add_nums(final_prod, next_prod, size - 1);
> 	}
> 	for (index = 0; final_prod[index]; index++)
> 	{
> 		if (final_prod[index] != 'x')
> 			putchar(final_prod[index]);
> 	}
> 	putchar('\n');
> 
> 	free(next_prod);
> 	free(final_prod);
> 
> 	return (0);
